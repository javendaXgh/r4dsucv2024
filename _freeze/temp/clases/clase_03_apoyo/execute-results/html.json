{
  "hash": "418475f3d5f745199bd5a4da8020ebc9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Clase 3- Apoyo\"\n---\n\n\n\n\n\n\n\n\nEste material fue compilado y adaptado por José M. Avendaño teniendo parcialmente códigos y conceptos desarrollados por [Diego Kozlowski y Juan Barriola](https://github.com/DiegoKoz/intro_ds) para un curso de R.\n\n## R base\n\nCon *R base* nos referimos a los comandos básicos que vienen incorporados en el R, sin necesidad de cargar librerías.\n\n## Uso de la consola como una calculadora- operaciones aritméticas\n\n-   En la consola podemos hacer calculos tal cual si estuviesemos usando una calculadora\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5*3+6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n\n```{.r .cell-code}\n5*(3+6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 45\n```\n\n\n:::\n:::\n\n\n\n\n\n\ntener presente el uso de los paréntesis y el orden en que serán ejecutadas las operaciones matemáticas\n\n## Definición de objetos\n\nLos **Objetos/Elementos** constituyen la categoría esencial del R. De hecho, todo en R es un objeto, y se almacena con un nombre específico que **no debe poseer espacios**. Un número, un vector, una función, la progresión de letras del abecedario, una base de datos, un gráfico, constituyen para R objetos de distinto tipo. Los objetos que vamos creando a medida que trabajamos pueden visualizarse en el panel derecho superior de la pantalla (el *Environment*).\n\nEl operador **`<-`** (**Alt + Guión**) sirve para definir un objeto. **A la izquierda** del **`<-`** debe ubicarse el nombre que tomará el elemento a crear. **Del lado derecho** debe ir la definición del mismo.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- 1\n```\n:::\n\n\n\n\n\n\nPor ejemplo, podemos crear el elemento **A**, cuyo valor será 1. Para esto, debemos *correr* el código presionando **Ctrl + Enter**, con el cursor ubicado en cualquier parte de la línea. Al definir un elemento, el mismo queda guardado en el ambiente del programa, y podrá ser utilizado posteriormente para observar su contenido o para realizar una operación con el mismo.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nA+6\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\n\n\nAl correr una linea con el nombre del objeto, la consola del programa nos muestra su contenido. Entre corchetes observamos el número de orden del elemento en cuestión. Si corremos una operación, la consola nos muestra el resultado de la misma.\n\nEl operador **`=`** es **equivalente** a **`<-`**, pero en la práctica no se utiliza para la definición de objetos.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nB = 2\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n**`<-`** es un operador **Unidireccional**, es decir que:\\\n`A <- B` implica que **A** va tomar como valor el contenido del objeto **B**, y no al revés.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- B\nA      # Ahora A toma el valor de B, y B continúa conservando el mismo valor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nB\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Variables\n\nPueden contener cualquier estructura de datos como una matriz, un valor numérico, un texto, un vector y otras que se verán más adelante. Son creadas mediante el uso del operador de asignación.\n\n## Funciones Precargadas:\n\nRBase cuenta con diversas funciones que ya vienen definidas con el lenguaje de programación. Muchas de ellas son comandos básicos para realizar rutinas de programación. Otro lote de funciones, distinto a otros lenguajes, son funciones para aplicar métodos inherentes a la estadística. Cuando se vea un texto en un script que está asociado a un verbo, o proceso, y posterior al nombre, viene acompañado de un signo de inicio de paréntesis y finaliza con otro signo de cierre de paréntesis, se está en presencia de una función. En algunos casos entre ambos signos de paréntesis aparecerá un texto que puede estar entre comillas, sin comillas y en otros casos varios textos separados por comas. Cuando se da este último caso se refiere a que la función necesita distintos argumentos para poder ejecutarse.\n\nEjemplos:\n\n1.  Función sin argumento\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    Sys.Date()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"2024-10-23\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n2.  Función con un argumento\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    head(mtcars)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n                       mpg cyl disp  hp drat    wt  qsec vs am gear carb\n    Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n    Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n    Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n    Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n    Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n    Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n    ```\n    \n    \n    :::\n    :::\n\n\n\n\n\n\n3.  Función con múltiples argumentos\n\n\n\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    # asignación variables\n    velocidad <- cars$speed\n    distancia <- cars$dist\n    \n    # crear un gráfico de tipo scatter plot (diagrama de dispersión )\n    plot(velocidad, distancia)\n    ```\n    \n    ::: {.cell-output-display}\n    ![](clase_03_apoyo_files/figure-html/unnamed-chunk-7-1.png){width=672}\n    :::\n    :::\n\n\n\n\n\n\n## Tipos de datos\n\nCuando queremos saber con cuál tipo de datos estamos trabajando necesitamos usar la función class()\n\n\\`\\`\\`{r data_types, include=TRUE, echo=TRUE\n\nLas funciones son series de procedimientos estandarizados, que toman como imput determinados argumentos a fijar por el usuario, y devuelven un resultado acorde a la aplicación de dichos procedimientos. Su lógica de funcionamiento es:\\\n`funcion(argumento1 = arg1, argumento2 = arg2)`\n\n### Otros ejemplos de funciones:\n\n-   paste() : concatena una serie de caracteres, pudiendo indicarse cómo separar a cada uno de ellos\\\n-   paste0(): concatena una serie de caracteres sin separar\n-   sum(): suma de todos los elementos de un vector\\\n-   mean() promedio aritmético de todos los elementos de un vector\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npaste(\"Pega\", \"estas\", 4, \"palabras\", sep = \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Pega estas 4 palabras\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#Puedo concatenar caracteres almacenados en objetos\nA= 'nombre'\nB= 'apellido'\nC= 'ciudad'\npaste(A, B, C, sep = \"**\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"nombre**apellido**ciudad\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Paste0 pega los caracteres sin separador\npaste0(A, B, C)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"nombreapellidociudad\"\n```\n\n\n:::\n\n```{.r .cell-code}\n1:5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(1:5, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Vectores\n\nSon colecciones de elementos que tienen que ser exclusivamente del mismo tipo, de la misma clase. Se usa la c () para declarar un vector. Los elementos que conforman el vector van separados por comas. Los vectores pueden, y es lo más común, les asignamos nombre como lo vimos con las variables. Incluso podemos tener vectores con una solo elemento (que de por si son las variables que ya estudiamos).\n\n## Tipos de vectores\n\n### vectores - numeric\n\nSi queremos preguntar lo hacemos con la función is.numeric()\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx=10\nis.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nEn la lámina anterior vimos que el valor que retornó class(x) fue \"numeric\".\n\n-   **Númericos**: son aquellos que incluyen números enteros y decimales. En otros lenguajes se les conocen como números de tipo \"float\" y \"double\".\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2\n\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### vectores - integer\n\n-   **Enteros**: hay casos en los que es necesario trabajar con números enteros sin que contenga ningún decimal. Estos números se declaran con el uso de una L posterior al número.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 2L\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nEjemplo de una operación:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2.7\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ny <- 3L\nclass(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### vectores - lógicos\n\n-   **Lógicos:** Sirven para representar datos que solo pueden tener uno de estos dos valores\n\n    -   verdadero - TRUE\n    -   falso - FALSE\n\n### Operadores lógicos:\n\n-   $>$ (mayor a)\n-   $>=$ (mayor o igual a)\n-   $<$ (menor a)\n-   $<=$ (menor o igual a)\n-   $==$ (igual a)\n-   $!=$ (distinto a)\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Redefinimos los valores A y B\nA <- 10\nB <- 20\n\n# Realizamos comparaciones lógicas\nA >  B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nA >= B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nA <  B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nA <= B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nA == B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nA != B\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nC <- A != B\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n\nComo muestra el último ejemplo, el resultado de una operación lógica puede almacenarse como el valor de un objeto.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2.7\ny <-3L\nz <- x==y\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nacabamos de usar el operador '==' que nos sirve para hacer una comparación de igualdad entre dos **objetos**. Lo que estamos es preguntando si son iguales el uno al otro y la respuesta que obtenemos es de tipo lógica booleana TRUE o FALSE\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE*4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nFALSE*2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\n\n\nacabamos de ver coerción. Forzar a un cambio de un tipo de dato en otro tipo de dato. Los TRUE pueden ser interpretados mediante la coerción como 1 y los FALSE como 0\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# dos es igual a 3?\n2==3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# dos es distinto de tres? (tener presente que el ! \n# precediendo al igual quiere decir que es lo inverso \n# al igual, es decir, distinto)\n2!=3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#dos es menor que tres?\n2<3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#juan es igual a pedro? (hablamos del texto)\n'juan'=='pedro'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# el texto jose es igual a jose?\n'jose'=='jose'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n#dos es igual a dos?\n2==2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# a es menor que b?\n'a'<'b'\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# a es mayor que 8?\n'a'>8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# a es igual a 1?\n'a'==1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### vectores - character\n\n-   **Datos de caracteres:** se usan para almacenar cadenas de caracteres como por ejemplo un nombre, una oración, o cualquier valor que el computador no deba entender como un objeto lógico, número entero, númerico, matriz, etc. El valor debe estar declarado entre comillas simples \" o comilla sencilla '. Prestar atención a no usar la tipo tilde ´ o cualquiera diferente a las mencionadas\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnombre <- 'jose miguel'\nno_es_numero <- '2'\nno_es_numero\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(no_es_numero)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnchar(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnchar('hola')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nnchar(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nnchar(1532)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\n### vectores - Date\n\n-   **Fechas** El trabajo con las fechas puede llegar a ser un tanto complejo y será abordado de forma más intensiva adelante. Revisando algunas de las formas de trabajar con fechas tenemos el uso de las funciones Date y POSIXct\n    -   La función Date solo almacena la fecha calendario\n\n    -   La función POSIXct puede almacenar en conjunto hora y fecha\n\nLas fechas se representan, en cualquiera de los casos como la cantidad de días (date) o segundos (POSIXct) que han transcurrido desde el 1 ero de enero de 1970.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfecha1 <- as.Date('2020-01-31')\nfecha1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2020-01-31\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(fecha1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(fecha1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18292\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfecha2 <- as.POSIXct('2020-01-31 11:15')\nfecha2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2020-01-31 11:15:00 -04\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(fecha2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1580483700\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(fecha2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"POSIXct\" \"POSIXt\" \n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Vectores repaso:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumeros <- c(1,2,5,7)\nnumeros\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 5 7\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(numeros)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntextos <- c('juan','eliana','maria')\nclass(textos)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntextos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"juan\"   \"eliana\" \"maria\" \n```\n\n\n:::\n\n```{.r .cell-code}\nlogicos <- c(TRUE, FALSE, TRUE)\nclass(logicos)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n\n```{.r .cell-code}\nis.numeric(numeros)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.logical(textos)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(textos)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nunico <- c('aula')\nunico\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"aula\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(unico)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\nerrado <- c('texto', 1)\nerrado\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"texto\" \"1\"    \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(errado)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nerrado <- c('texto', 1)\nerrado\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"texto\" \"1\"    \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(errado)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#aplicó la coercion\n```\n:::\n\n\n\n\n\n\n## Estructuras de Datos/ Objetos:\n\nTodo lo que existe dentro de R es un objeto: funciones, vectores, etc. En R se puede trabajar con una gran cantidad de objetos distintos tanto en su tipo como tenerlos dentro de una sesión de trabajo.\n\nEstas son algunos de los objetos que contienen datos con los cuales trabajaremos a lo largo del curso.\n\n-   Valores\n-   Vectores\n-   Listas\n-   Data Frames\n-   Tibbles\n\nNo obstante, existen estructuras más complejas que no son de tipo tabular que no serán abordadas como la raster layers.\n\n## Caracteres especiales\n\n-   R es sensible a mayúsculas y minúsculas, tanto para los nombres de las variables, como para las funciones y parámetros.\n\n-   El **numeral** `#` se utiliza para hacer comentarios. Todo lo que se escribe después del \\# no es interpretado por R. Se debe utilizar un \\# por cada línea de código que se desea anular\n\n-   Los **corchetes** `[]` se utilizan para acceder a un objeto:\n\n    -   en un vector\\[n° orden\\]\n    -   en una tabla\\[fila, columna\\]\n    -   en una lista\\[n° elemento\\]\n\n-   el signo **\\$** también es un método de acceso. Particularmente, en los dataframes, nos permitira acceder a una determinada columna de una tabla\n\n-   Los **paréntesis**`()` se utilizan en las funciones para definir los parámetros.\n\n-   Las **comas** `,` se utilizan para separar los parametros al interior de una función.\n\n## Nombres Variables\n\n## Ambientes de trabajo\n\nHay algunas cosas que tenemos que tener en cuenta respecto del orden del ambiente en el que trabajamos:\n\n-   Working Directory: Es el directorio de trabajo. Pueden ver el suyo con `getwd()`, es *hacia donde apunta el código*, por ejemplo, si quieren leer un archivo, la ruta del archivo tiene que estar explicitada como el recorrido desde el Working Directory.\n-   Environment: Esto engloba tanto la información que tenemos cargada en *Data* y *Values*, como las librerías que tenemos cargadas mientras trabajamos.\n\nEs importante que mantengamos bien delimitadas estas cosas entre diferentes trabajos, sino:\n\n1.  El directorio queda referido a un lugar específico en nuestra computadora.\n\n-   Si se lo compartimos a otro **se rompe**\n-   Si cambiamos de computadora **se rompe**\n-   Si lo cambiamos de lugar **se rompe**\n-   Si primero abrimos otro script **se rompe**\n\n2.  Tenemos mezclados resultados de diferentes trabajos:\n\n-   Nunca sabemos si esa variable/tabla/lista se creo en ese script y no otro\n-   Perdemos espacio de la memoria\n-   No estamos seguros de que el script cargue todas las librerías que necesita\n\nRstudio tiene una herramienta muy útil de trabajo que son los **proyectos**. Estos permiten mantener un ambiente de trabajo delimitado por cada uno de nuestros trabajos. Es decir:\n\n-   El directorio de trabajo se refiere a donde esta ubicado el archivo .Rproj\n-   El Environment es específico de nuestro proyecto.\n\nUn proyecto no es un sólo script, sino toda una carpeta de trabajo.\n\nPara crearlo, vamos al logo de nuevo projecto (Arriba a la derecha de la panatalla), y elegimos la carpeta de trabajo.\n\n## Tipos de archivos de R\n\n-   **Script**: Es un archivo de texto plano, donde podemos poner el código que utilizamos para preservarlo\n-   **Rmd**: También sirve para guardar el código, pero a diferencia de los scripts, se puede compilar, e intercalar código con resultados (este archivo es un rmarkdown)\n-   **Rproject**: Es un archivo que define la metadata del proyecto\n-   **RDS y Rdata**: Dos formatos de archivos propios de R para guardar datos.\n-   **qmd**: archivo de Quarto, el cual es un sistema de publicaciones (página web, blogs, que puede contener códigos y otros objetos resultados de una rutina de programación acompañados por texto legible.\n-   \n\n## Remover objetos del Global Environment\n\nEn caso de querer remover un objeto (todo lo que existe dentro del programa que estamos ejecutando) del \"global environment\" podemos usar la función rm() teniendo como argumento el nombre del objeto que queremos remover\n\nrm(\"nombre\")\n",
    "supporting": [
      "clase_03_apoyo_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}