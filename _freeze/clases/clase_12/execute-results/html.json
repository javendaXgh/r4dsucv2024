{
  "hash": "1afa2412ddd1c96568173986076922af",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Clase 12- Selección, Agrupar y Crear Sumarios\"\n#format: live-html\ndate: \"Noviembre 25, 2024\"\nauthor: \"MSc. José M. Avendaño\"\n# output:\n#   html_document:\n#     toc: yes\nformat: \n  revealjs:\n    incremental: true   \n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# cargar librerías\nlibrary(tidyverse)\nlibrary(gapminder)\n\n# la df de gapminder viene precargada en el paquete gapminder. Por eso no la vamos a importar con read_xlsx\ndf_gapminder <- gapminder\n```\n:::\n\n\n\n## Varios y Puntos Pendientes\n\n-   Investigación de funciones no vistas: método sugerido\n\n-   Verificar salidas\n\n-   NA´s\n\n-   Aspectos para hacer render del qmd:\n\n    -   environment\n\n    -   funciones no compatibles\n\n-   Láminas pasadas contienen información complementaria\n\n## Objetivo\n\nRealizar agrupaciones de datos contenidos en una DF según uno o más criterios. Posterior a tener los datos agrupados obtendremos valores que totalizan valores por los grupos creados.\n\n![](images/im-or-trans.png)\n\n## Agrupar\n\nLa mayoría de las operaciones de datos se realizan en grupos definidos por variables. group_by() toma un tbl existente y lo convierte en un tbl agrupado donde las operaciones se realizan «por grupo». ungroup() elimina la agrupación.\n\n## Agrupar por un Atributo\n\nlos datos se pueden agrupar según un criterio, por ejemplo, según el año o según el continente o alguna variable categórica que contenga el conjunto de datos\n\n## Agrupar por más de un Atributo\n\nTambién se pueden agrupar por diversos criterios, los cuales serán aplicados jerarquicamente según el orden de aparición de los criterios pudiendo llevar a resultados distintos.\n\n## Reframe\n\nCrea una nueva df aplicando funciones a las columnas de una df existente. También se usa summarise, pero es recomendable usar esta función que es más reciente\n\nExiste pérdida de estructura de datos original\n\nSe puede hacer en algunos casos el ungrup para desagrupar\n\n## Filtrado según datos Externos\n\nPuede ser necesario que los datos a filtrar provengan de una fuente distinta a los datos disponibles en una DF. Es necesario realizar el trabajo con precisión y cuidado para evitar perder valores.\n\n## Factores\n\nSon una estructura de datos que agrupa valores categóricos, como nombres de días de la semana, categorías de productos o cualquier otro tipo de variable que tenga un conjunto limitado de posibles valores.\n\nLos factores son útiles porque permiten a las funciones estadísticas tratar estos tipos de datos de manera más eficiente.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}